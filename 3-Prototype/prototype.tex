\chapter{Prototypical Implementation}
\label{ch:prototype}

\vspace{-1cm}
\begin{center}
Eduard Hirsch
\end{center}

\section{Project Structure}
\label{sec:project-structure}

Before introducing the actual architecture and implementation, the structure of the project is described in order to know what to find where. In Figure \ref{fig:directory-structure} the main directories are shown which also separate the main components of the business network.

\begin{figure}[htbp]
\centering
\begin{minipage}{5cm}
\dirtree{%
.1 Interlace Blockchain.
	.2 chain.
	.2 fabric.
	.2 webapp.
}
\end{minipage}
\caption{\bf\small Project Directory Structure}
\label{fig:directory-structure}
\end{figure}

Explaining further, the folder \textit{"chain"} contains a \textit{Hyperledger Composer} implementation of a business network. This business network is the main implementation of the INTERLACE work to create a working blockchain that consists mainly of chaincode\footnote{In the Hyperledger framework the language of Smart Contracts is referred to as `chaincode'.} implementations, but also of scripts to deploy and update the chaincode as well as to make the network accessible by starting it on the Hyperledger Fabric chain.

Hyperledger Composer aims to make blockchain application development easier by offering a large toolset together with a powerful framework. Its main purpose is to accelerate the time needed between requirements gathering and a final blockchain application, delivering fully functional business applications. Composer facilitates JavaScript and node.js in combination with proprietary language extensions to generate such business application and to run them on a Hyperledger Fabric instance.

\textit{"fabric"} is the Hyperledger Fabric base blockchain needed for running a business network where the chaincode bits are executed on. The chaincode bits from directory \textit{chain} are compiled to a \textit{.bna} file (``blockchain network archive'') which is then deployed to a Fabric network. These bna-files (also called banana files) can't be used by default by Hyperledger Fabric. They are, rather, part of a virtual infrastructure-like environment provided by Hyperledger Composer. Thus the API components of Composer provide wrappers to make a Composer implementation run on a pure Fabric network.

Finally a web application has been implemented which uses AngularJS, a front-end framework provided by Google,  to work with the blockchain. This application is found in \textit{webapp}. This application uses a Swagger\footnote{\url{https://swagger.io/}}-based REST-server implementation which comes with the Hyperledger Composer framework.

A more detailed description of the directory structures can be found in subsequent sections where the respective parts are explained in depth.

\section{Architecture}

The core architecture of the INTERLACE project presented next is multi-layered and concentrates on being scalable and highly distributable, in contrast to the current monolithic payment platform used by Sardex.

The chosen blockchain approach is going to be explained in detail. The technical challenges during the planning of that implementation strategies are discussed in subsequent sections of this chapter.

\subsection{Sardex Network}

In deliverables D2.1 and D3.1 the current architecture was specified using the AS(I)M approach and, as mentioned before, a working client-server application based on message passing was developed. This application was realized using the ICEF-framework which is founded on abstract state machines applying a programming language similar to ASM logic definitions.

The high-level functional model of D2.1 and D3.1 was used to derive a new payment network based on the blockchain approach. The new network platform involves using a publicly maintained and an easy-to-use blockchain which supports the principle of an interest-free mutual credit system enabling account-based balances rather than token-based (asset-based) currencies only. These considerations led to a prototypical implementation using Hyperledger Fabric together with Hyperledger Composer.

Independent of the choice of blockchain environment, it was also important to develop a central payment network which is not only reliable and verifiable but also (to a specific extent) controllable in order to impose the basic Sardex payment rules on it. Thus, the first implementation of the INTERLACE blockchain is actually centralised. The advantage is easy scalability to a distributed architecture as more circuits are added in other parts of Italy and beyond.

\subsection{Hyperledger Fabric Network}

The given network constraints were used while creating a new Hyperledger Fabric network which sets up a core environment offering a basic blockchain to interact with. Next, we discuss in some detail the actual implemented network along with a description for the various parts.

Figure \ref{fig:prototype-net} shows the current working environment, which uses the possibilities offered by Hyperledger Fabric. Upon closer scrutiny, Fabric actually imposes a structure on a newly created network, of which the following main components can be singled out for INTERLACE:

\begin{itemize}
	\item Sardex as participating \textbf{organisation}
		\subitem One  \textbf{peer} (named: peer0.sardex.sardex.net)
		\subitem Clients and Services connecting to the network
		\subitem Sardex Membership Provider \textbf{(MSP)} with ID SardexMSP
	\item "Interlace" pseudo organisation
		\subitem An \textbf{orderer} (named: orderer.sardex.net)
		\subitem Interlace Membership Provider \textbf{(MSP)} with ID InterlaceOrdererMSP
	\item Certification Authority (\textbf{CA})
\end{itemize}

Starting from a \textbf{CA}, a user may issue a unique identity which can be verified anytime by anyone participating in the network. These identities are part of the process of giving members of the circuit the right to work with and facilitate the network with particular roles and access privileges. The actual empowering of a user takes place inside of the membership provider (\textbf{MSB}).

However, the power of an MSP goes beyond simply keeping track of who is a network participant or member of a particular channel. An MSP is able to identify specific roles an actor might play  within the scope of the organisation the MSP represents (e.g., admins, or as members of a sub-organisation group), and in general defines the foundation for giving access privileges in the context of a network and channel (e.g., channel admins, readers, writers). More details can be found in the documentation on the Hyperledger Fabric website.\footnote{\url{https://hyperledger-fabric.readthedocs.io/en/master/membership/membership.html}}

For the sake of simplicity and in order to set up the prototype network quickly, access/role management has been reduced to a minimum. Section \ref{sec:id-management} focuses on a more detailed explanation on how these aspects work or might be changed in case of larger-scale scenarios.  

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth, clip, trim=1mm 1mm 1mm 1mm]{Figures/basic-network}
  \caption{\bf\small Network structure implemented by the Prototype}
  \label{fig:prototype-net}
\end{figure}

The single \textbf{orderer} node in Figure \ref{fig:prototype-net} is responsible for atomic broadcasts, orders/batches transactions, and also signs each batch (block) to create unique and well-defined chains. The membership provider of the orderer uses a central and pre-configured certification authority \textbf{CA}.

This network configures and starts one \textbf{peer}. This peer can be called the core of the environment because its main task is to handle the so-called \textit{smart logic} (chaincode). More specifically, peers maintain the ledger by first endorsing a transaction (e.g.\ credit and debit transfers in the case of INTERLACE), which they do by simulating it.\footnote{This is the execution step in the Execute-Order-Validate Hyperledger architecture \cite{AndroulakiEtAl2018}} Then, in an intermediate step it is validated by the orderer and finally the peers commit it to their local ledger.

A very simple network is defined and described by the above scenario, which can be set up following the instructions of Section \ref{sec:prototype}. Certainly, this scenario needs to be extended to a real-world environment, a few hints and considerations for which will be given in Figure \ref{fig:prototype-net-ext} and explained in Section \ref{sec:future-scene}.

\subsection{Network Configuration Files}
\label{sec:net-conf-files}

There are three main configuration files providing a basic foundation for generating a preconfigured network. Those files are used to create the corresponding certificates as well as configuration files to spin up virtualised containers. Thus, the following three yaml files are an example of how to create a particular net as described in the previous section where the INTERLACE network was shown:

\begin{enumerate}
	\item crypto-config.yaml
	\item configfx.yaml
	\item docker-compose.yaml
\end{enumerate}

\textbf{crypto-config.yaml}

The \textit{crypto-config.yaml} contains the network topology and therefore defines its basic structure. With the configuration file it is possible to use a tool called \textit{cryptogen} which takes crypto-config.yaml as input to generate the cryptographic material necessary to run the blockchain. More specifically, \textit{cryptogen} generates the keys for both the organisations and the components that belong to those organisations.

Listing \ref{lst:cryConOrderers} shows a part of crypto-config.ymal that defines one or more orderers. The yaml definition of the network peers is depicted in Listing \ref{lst:cryConPeers}.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=yaml,firstnumber=1,caption={\bf\small crypto-config.yaml excerpt -- Orderer(s) definition},captionpos=b,label=lst:cryConOrderers]
OrdererOrgs:
  # -----------------------------------------------------------------
  # Orderer
  # -----------------------------------------------------------------
  - Name: InterlaceOrderer
    Domain: sardex.net
    # ---------------------------------------------------------------
    # "Specs" - See PeerOrgs below for complete description
    # ---------------------------------------------------------------
    Specs:
  	  - Hostname: orderer
\end{lstlisting}
\end{minipage}
\end{center}

Listing \ref{lst:cryConOrderers} shows that in the case of INTERLACE only one orderer is specified in line 5, with the name \textit{InterlaceOrderer}. The network domain \textit{sardex.net} is defined with the \textit{Domain} key. Thus, together with the \textit{Hostname} definition in line 11, the INTERLACE orderer can be reached using \textit{orderer.sardex.net}.

Peers can be defined for the various organisations. For example, Listing \ref{lst:cryConPeers} shows the definitions specific to the INTERLACE project. The first and only organisation for now is \textit{Sardex} in the \textit{sardex.net} domain. Similarly, Sardex gets the \textit{Domain}-name \textit{sardex.sardex.net}. Taking a look at the hierarchy one level down, peers will receive domain names like peer0.sardex.sardex.net or peer1.sardex.sardex.net. As the template \textit{Count}-key only defines a value of \textit{1}, there will only be one peer with sub-domain name \textit{peer0}.

As mentioned above, user management is handled on a very small scale. Thus, when setting the user count to 0 in line 18 no users in addition to the administrator are defined.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=yaml,firstnumber=1,caption={\bf\small crypto-config.yaml excerpt - Peer(s) definition}, captionpos=b,label=lst:cryConPeers]
PeerOrgs:
  # -----------------------------------------------------------------
  # Org1
  # -----------------------------------------------------------------
  - Name: Sardex
    Domain: sardex.sardex.net
    EnableNodeOUs: true
    # Peer nodes and if applicable host name templates
    # for the newly created peers
    Template:
      Count: 1
    # -----------------------------------------------------------------
    # "Users"
    # -----------------------------------------------------------------
    # Count: The number of user accounts _in addition_ to Admin
    # -----------------------------------------------------------------
    Users:
      Count: 0
\end{lstlisting}
\end{minipage}
\end{center}

For more details on how to configure the network to a greater depth, kindly consult the official Hyperledger Fabric documentation,\footnote{\url{https://hyperledger-fabric.readthedocs.io}} which is a valuable source and should be studied in detail in order to build Fabric-based networks.

In addition to the original Fabric documentation a reference guide called "Hands-On Blockchain with Hyperledger" \cite{HandsOnBlockchainHyperledger2018} was used to build this network.

\textbf{configtx.yaml}

The second configuration file is named \textit{configtx.yaml} and contains different but also some redundant configuration bits for the blockchain network. Another tool called \textit{configtxgen} picks up configtx.yaml and uses it to create configuration artefacts, thereby setting up a basic structure utilized by the actual blockchain network. These artefacts are:

\begin{itemize}
	\item orderer \textit{genesis block}
	\item channel \textit{configuration transaction}
	\item an \textit{anchor peer transaction} for each peer organisation
\end{itemize}

As stated in the Fabric documentation,\footnote{\url{https://hyperledger-fabric.readthedocs.io/en/release-1.3/build_network.html}}
\begin{quote}
\small
The orderer block is the Genesis Block for the ordering service, and the channel configuration transaction file is broadcast to the orderer at Channel creation time. The anchor peer transactions, as the name might suggest, specify each Organisation's Anchor Peer on this channel.
\end{quote}

The core configuration excerpt can be seen in Listing \ref{lst:configTxProfiles}. First, it defines an orderer genesis block called \textit{InterlaceOrdererGenesis} containing one orderer handled by organization \textit{Interlace} together with some capabilities (not discussed here) as well as a consortium using the network.

Second, it sets up a channel \textit{InterlaceChannel} which is connected to a consortium named \textit{InterlaceConsoritum}. This channel is used for credit and debit operations where currently only one organisation is defined: namely, \textit{Sardex}.

Third, as mentioned initially, anchor peers are recorded into the ledger. This is done by submitting a transaction to the ledger which contains the main anchor peers. Anchor peers may be defined for an organization using the config-property \textit{AnchorPeers}. The project defines a host called \textit{"peer0.sardex.sardex.net"} that provides services at port \textit{"7051"}, consistently with the crypto-config.yaml file. The host information is written into that initial transaction.

\begin{center}
\vspace{-.3cm}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=yaml,firstnumber=1,caption={\bf\small configtx.yaml excerpt -- Profiles definition}, captionpos=b,label=lst:configTxProfiles]
Profiles:
    InterlaceOrdererGenesis:
        Capabilities:
            <<: *ChannelCapabilities
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *Interlace
            Capabilities:
                <<: *OrdererCapabilities
        Consortiums:
            InterlaceConsortium:
                Organizations:
                    - *Sardex
    InterlaceChannel:
        Consortium: InterlaceConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations:
                - *Sardex
            Capabilities:
                <<: *ApplicationCapabilities
\end{lstlisting}
\end{minipage}
\vspace{-.3cm}
\end{center}

\textbf{docker-compose.yaml}

Docker and Docker Compose are the core technologies used to start containerized services which finally start the actual blockchain and its components. Hyperledger Fabric developer offer images which are ready to be started right away when provided with the correct configuration locations.

The compose file defines four container images. In Listing \ref{lst:composeImages} a shortened compose yaml-file shows the services (or images) started when \textit{docker-compose up} is called. One for the certification authority (line 2), one for the orderer (line 4), one for the peer (line 6), and also an additional container (line 8) the peer is storing data to. That additional container is a NoSQL database called CouchDB. 

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=yaml,firstnumber=1,caption={\bf\small docker-compose.yaml excerpt}, captionpos=b,label=lst:composeImages]
services:
  ca.sardex.sardex.net:
    [...]
  orderer.sardex.net:
    [...]
  peer0.sardex.sardex.net:
    [...]
  couchdb:
    [...]
\end{lstlisting}
\end{minipage}
\end{center}

Also docker-Composer creates a virtual network environment where the service containers defined here can communicate between themselves using the particular domain names used in this configuration file.

Each of the services starts its respective application, which handles the allotted requests. The certification authority (CA) is started by calling \textit{fabric-ca-server}, the orderer executes the eponymous command \textit{orderer}, the only peer (peer0) runs \textit{peer node start}, and the CouchDB image "couchdb" is started without specifying an additional command because the start-up process is handled by the container image itself.   

The CA might be replaced for a real-world production system by a different authority supporting ECDSA certificates. Fabric only supplies this implementation to get a network quickly up and running.

\textbf{Cryptographic Material}

Except for CouchDB, all other services need to be configured with the network structure as well as the appropriate public-private key infrastructure. In the \textit{chain} directory another folder called \textit{network} can be found. This folder contains templates of configtx.ymal as well as crypto-config.yaml. 

These template are, as mentioned, for generating the genesis block as well as the keys needed for the corresponing service. We have scripted the generation: it can be performed by calling \textit{build.sh}, which is also located in the same directory as the yaml-files. The results of running the build script are
\begin{itemize}
	\item interlace-channel.tx
	\item interlace-genesis.block
	\item crypto-config\ directory
\end{itemize}
These generated files as well as the directory are finally shared using docker volumes\footnote{\url{https://docs.docker.com/storage/volumes/}} for the respective services. A detailed description of how to configure the services can be found in the online documentation of Fabric\footnote{\url{https://hyperledger-fabric.readthedocs.io}} but also in \cite{HandsOnBlockchainHyperledger2018}.

%\subsection{cto-model}
%\label{sec:cto-model}

%The CTO-model is specific to Hyperledger Composer framework and offers a possibility to set-up a ground model which is imposed onto the chaincode implementation as well as on the blockchain residing on the peers. 

%The model created for INTERLACE project has 2 main \textit{transactions}, that are \textit{CreditTransfer} and \textit{DebitTransfer} and inherited by \textit{Transfer}. \textit{DebitTansfer} actually also needs a second transaction named \textit{DebitTransferAcknowledge} to be performed, thus it may be counted as a main transaction as well. Two other transactions supporting the functionality of the network are \textit{InitBlockchain} and \textit{CleanupPendingTransfer}.

%Transfers are handling \textit{assets}, which means creating and updating them. When the main transfers are executed they are changing \textit{Account}-assets, namely, \textit{SysAccount} and \textit{MemberAccount} which are inheriting from it. \textit{DebitTransfer} also needs \textit{PendingTransfer}-asset for creating transfers which haven't yet been confirmed. \textit{DeltaDebt} collects all transfers with the negative amount portion to log when the debt has to be paid back.

%\begin{figure}[htbp]
%  \centering
%  \includegraphics[width=1.0\textwidth]{Figures/cto-model}
%  \caption{\bf\small CTO Model Structure used by Hyperledger Composer}
%  \label{fig:DCN-cto}
%\end{figure}

%In order to perform credit or debit operations a \textit{participant} need to be registered. For the prototype they are quite reduced like the assets, however, there two participants derived from \textit{Member} called \textit{Subscriber} and \textit{Individual}. Those members may own an account asset which can be used then to transfer money from one account to another one.

%On several occasions event are emitted which may be consumed by an application or a user to react to specific issues happened during a transaction. There are many different events interesting for a user but for the moment there are three implemented. One is for a forecast of a possible limit violation named \textit{LimitViolation}, \textit{RequestDebitAcknowledge} asks a user to give an acknowledgement to a pending transaction and last \textit{DebitAcknowledgeInvalid} informs that the acknowledgement for a pending transaction got denied or has been invalid.

%Finally there are couple of \textit{enum} types giving states names like for operations and units as well as account and group types.

%A detailed explanation of the model language can be found the official Hyperledger Composer documentation\footnote{\url{https://hyperledger.github.io/composer/latest/reference/cto_language.html}}

\section{Prototype}
\label{sec:prototype}

The prototype is a blockchain realisation of INTERLACE, can be found on GitHub\footnote{\url{https://github.com/InterlaceProject/InterlaceBlockchain}} and is based on the specifications created in deliverable D3.1 \cite{INTERLACE_D31} along with the ASIM specification of the requirements.

First, it is necessary to install the prerequisites which are available for Linux and Mac OS. Currently these are the recommended operating systems. However, with additional effort it might be possible to run the INTERLACE blockchain on Windows directly. To support Windows users a virtual machine set-up is also available.

Additionally, it is also important to set up a development environment described in the Composer GitHub repository. Even if development is not planned and setting up a complete environment not necessary, it is still advisable to install and start Composer Playground. Playground enables someone to connect, alter, and test the INTERLACE payment network. Nevertheless, Playground is not required and it might be possible to use composer-cli or other methods to utilise the network.

\subsection{Install}
\label{subsec:install}
This part of the documents talks about how to set up and run the business network on your machine. However, before it is actually possible to begin it is necessary to install the pre-requisites which are listed at the Hyperledger Composer documentation.\footnote{\url{https://hyperledger.github.io/composer/latest/installing/installing-prereqs.html}} The website also offers a download where a script for installing all the requirements for a machine is provided.

Nevertheless, for Windows users these scripts won't help because for now most of the packages are not yet prepared (as of this writing) for a Windows operating systems. We have prepared a virtual machine also for this user group, which also installs all the necessary frameworks and software tools during provisioning. This virtual machine is controlled by vagrant\footnote{\url{https://www.vagrantup.com/}} and uses hyper-v or virtual box as hypervisor (two different branches). This VM configuration is published at GitHub\footnote{\url{https://github.com/hirsche/hyperledger}}.

\textbf{Environment Start-Up}

Once the Hyperledger environment is installed, the next step is to start the INTERLACE environment. To make communications uniform the blockchain is configured to publish all services under the host name "interlace.chain". To facilitate Windows users, in the suggested vagrant set-up the new hostname is added to your host-file at start-up time using the vagrant-hostmanager plug-in. Thus there is no need to configure the name manually.

\textbf{Configure Hostnames}

For non-vagrant users it is important before executing the local set-up to add a host name entry for "interlace.chain". Usually this entry will point to IP 127.0.0.1 (localhost). On a production system or if it was chosen to start the Hyperledger Composer services on a public interface, the IP needs to be fixed accordingly. Here is a list of host file locations according to different operating systems types:

\begin{itemize}
	\item Mac OS: /private/etc/hosts
    \item Linux: /etc/hosts
    \item Windows: C:\textbackslash Windows\textbackslash System32\textbackslash drivers\textbackslash etc\textbackslash hosts
\end{itemize}

The format may vary a little but usually a new host with its hostname is defined using its IP and the desired host name as

\begin{lstlisting}
	127.0.0.1        interlace.chain
\end{lstlisting}
Depending on the operating system, it might be also necessary to update and restart the corresponding services (e.g. MacOS).

\textbf{Run the Fabric blockchain (the first time)}

At this stage, the main configurations have been performed and Hyperledger Fabric can be started, which acts as a base for Hyperledger Composer. To continue, if not yet done the GitHub repository\footnote{\url{https://github.com/InterlaceProject/InterlaceBlockchain}} needs to be downloaded by using the git visioning system by calling:

\begin{lstlisting}[language=bash]
	git clone https://github.com/InterlaceProject/InterlaceBlockchain.git
\end{lstlisting}

In the directory "InterlaceBlockchain" that is created the business network implementation, including a web application, can be found. The next listing shows the bash script that downloads several Fabric docker containers and finally starts them using docker-composer:\footnote{\url{https://docs.docker.com/compose/}}

\begin{lstlisting}[language=bash]
	cd fabric
	./downloadFabric.sh # updates images - only the first time necessary
	./startFabric.sh # start up docker environment using docker-compose
\end{lstlisting}


%\textcolor{red}{Paolo: to here (2018-11-20)}


\textbf{Initialize Interlace-Chain}

Finally, after Fabric has been started the next step is to initialize the blockchain with

\begin{lstlisting}[language=bash]
	cd chain
	./initNetwork.sh # use Hyperledger Composer to create a business network and deploy it
\end{lstlisting}

\textbf{./initNetwork.sh} will copy all models and script to the network peers to make them accessible in the Hyperledger blockchain. The last step in the script starts the business network.

It may be more convenient to access the network and test CreditTransfer or DebitTransfer transactions using Playground. \textbf{data.json} should act as a helper to initialise the network by hand, but it is recommended to update the JavaScript function \textit{initBlockchain(transfer)} in \textit{./chain/lib/init.js}. That chaincode part is executed when transaction InitBlockchain is submitted. Be careful to run \textbf{InitBlockchain} only once otherwise errors or duplicate entries might happen resulting in an inconsistent chain.

\textbf{Network updates after chaincode changes}

After changes to the acl, cto, queries, the libraries, or other parts of the core chaincode application, the network needs to be updated. This can be achieved by executing

\begin{lstlisting}[language=bash]
	cd chain
	./updateNetwork.sh
\end{lstlisting}

This script reads the current version number of the \textit{package.json} file, increments it by one, and creates a new bna package. If the scripts are correct and the bna-package can be created it is deployed to the peers and the network is updated to a new, higher network version which will utilize the new bna package.

\textbf{Shutting down}

Sometimes it is useful to throw away everything and restart from scratch. To tear down Fabric and remove card left-overs execute:

\begin{lstlisting}[language=bash]
	cd fabric
	./teardownFabric.sh
	./deletePlaygroundCards.sh
\end{lstlisting}

\textbf{Start a REST server}

Once the network is running (no Playground needed) it is also possible to start an HTTP Server which allows to interact with the network over REST. The script

\begin{lstlisting}[language=bash]
	cd chain
	./startRestServer.sh
\end{lstlisting}

starts the server and provides GUI access to the RESTful interface by opening

\url{http://interlace.chain:3000/explorer}

in a browser. When accessing the REST interface from an external application, it may be reached over

\url{http://interlace.chain:3000/}

If the host interlace.chain has not been set up and all the services are running locally without a VM, it might be also possible to use localhost instead of interlace.chain as host name. Nevertheless, it is highly recommended to use "interalce.chain" because everything has been tested using that particular host name.

\subsection{Working with the environment}

Next, a closer look is taken on how the environment might be facilitated using different approaches. It is possible to connect to the chain using composer-cli, taking advantage of Composer Playground (the graphical interface) or using the simple web front-end created for the project.

\textbf{Start and test network with Playground}

If you've decided to install and use Composer Playground it can be started using this command

\begin{lstlisting}[language=bash]
	composer-playground
\end{lstlisting}

The standard configuration opens a browser connecting to Playground at localhost with port 8080. If you are running Playground in a separate virtual environment like e.g.\ in a docker container, it may be necessary to start the browser manually, determine the VM/Containers IPs, and fill in the address manually in the URL field.

\textbf{The Admin Cards}

Composer Playground helps by providing a basic web interface to interact with the Hyperledger Fabric blockchain, on top of which Hyperledger Composer acts as an additional wrapper. Composer creates cards in order to connect to the blockchain. These cards can be created over the Playground web interface or over the command line interface. For INTERLACE these cards are created by \textit{initNetwork.sh}, which is explained in Section \ref{sec:prototype}. When these scripts are executed, and no error messages are issued, two cards should have been created and should become visible when opening Hyperledger Playground. This is illustrated in Figure \ref{fig:admin-cards}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.5\textwidth]{Figures/admin-cards}
  \caption{\bf\small Admin Cards in Hyperledger Playground}
  \label{fig:admin-cards}
\end{figure}

These cards provide all the information needed to connect to the INTERLACE blockchain business network. In particular, in the present case two cards are installed:

\begin{itemize}
	\item Peer Admin Card (PeerAdmin@sardex-open-network)
	\item Business Network Card (admin@sardex-open-network)
\end{itemize}

\textit{Peer Admin Cards} are cards (as the name suggests) used to interact with the peers. Users connecting over that card receive the permissions to manage chaincode deployments or changes on the peers. Thus they are a crucial part of every network.

Access to Interlace/Sardex Business Network is granted to another user through the provision of a \textit{Business Network Card} which is called \textit{admin@sardex-open-network}.

For INTERLACE we currently only have one user in place, the admin user. However, if the network gets deployed it will become necessary to grant access to other users, which can be done by creating an additional Business Network Card for each new user. Be aware that for each new user a participant needs to be registered first in order to link it with a new network card. 

\textbf{Edit Network}

Figure \ref{fig:edit-network} illustrates how a particular business network may be edited over Playground directly. For INTERLACE this means that you can e.g.\ quickly try out some changes on the JavaScript files and see if the changes are deployable by pressing the "Deploy changes" button. However, most developers might prefer using a common IDE,\footnote{\url{https://en.wikipedia.org/wiki/Integrated_development_environment}} which offers far better assistance during development, and use the scripts \textit{initNetwork.sh} and \textit{updateNetwork.sh} provided.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{Figures/edit-network}
  \caption{\bf\small Edit a network in Hyperledger Playground}
  \label{fig:edit-network}
\end{figure}

\textbf{Test Network}

The INTERLACE blockchain might be also tested directly with Playground web interface instead of using the Composer cli tools or launching the additional web application provided. Figure \ref{fig:test-network} shows the Playground test environment that comes with Playground and is started by pressing "Test" in the menu bar.

On the left bar of that view you are provided with a list of the INTERLACE participants, assets, as well as entry call "All Transactions". As the menu names might suggest, when clicking on them a list of those items which have been created on the chain is displayed. E.g., this view in \ref{fig:test-network} lists all \textit{Individuals} taking part in the Interlace-Test network. As shown in the main area of the screenshot, two "Individual" participants have been registered. One member with ID "m1" and one with ID "m2".

In addition, it is possible here to add and change entries for participants and assets you might change for customised tests.

Finally, the "All Transactions" menu entry guides to a list of all transactions executed on the INTERLACE chain. This list contains of course not just the transactions somebody has submitted but also entries like e.g.\ "AddParticipant" or "IssueIdentity". Thus, all changes to the blockchain are recorded and can be found here.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth]{Figures/test-network}
  \caption{\bf\small Test a network in Hyperledger Playground}
  \label{fig:test-network}
\end{figure}

\textbf{Submit a transaction}

Figure \ref{fig:submit-credit-transfer} shows a submission dialog, which opens when the "Submit Transaction" button in screenshot \ref{fig:test-network} is pressed. This dialog gives the possibility to select one of all possible transactions executable on the INTERLACE network. In this dialog a \textit{CreditTransfer} has been selected.

In the black text-box the properties of that transactions can be provided as a JSON-String. The interface provides default transaction-specific values.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.5\textwidth]{Figures/submit-credit-transfer}
  \caption{\bf\small Submit a (credit) transfer in Hyperledger Playground}
  \label{fig:submit-credit-transfer}
\end{figure}

Once all the necessary properties have been provided, pressing "Submit" tries to commit the transaction to the blockchain. If an error is encountered, it is shown in red font attached to the same dialog. When everything goes as planned the transaction is endorsed, ordered, and committed to the peers. The execution results will finally show up in the JSON records used for the assets and participants as well as in the transaction log of the chain.

Details on how to configure and initialize INTERLACE transactions are covered in Section \ref{subsec:initblockchain} which discusses the technical details.

\textbf{Run Transactions with composer-cli}

Initialise network transaction:

\begin{lstlisting}[language=bash]
	composer transaction submit -c admin@sardex-open-network -d  '{ "$class": "net.sardex.interlace.InitBlockchain" }'
\end{lstlisting}

The InitBlockchain transaction sets up some basic accounts as well as demo members that can issue simple transactions right away.

Submit a credit transfer from account a1 to a2 with amount of 800 SRD:

\begin{lstlisting}[language=bash]
	composer transaction submit -c admin@sardex-open-network -d  '{ "$class": "net.sardex.interlace.CreditTransfer", "amount": 800, "fromAccount": "resource:net.sardex.interlace.CCAccount#a1", "toAccount": "resource:net.sardex.interlace.CCAccount#a2" }'
\end{lstlisting}

Submit a debit transfer from account a1 to a2 with amount of 200 SRD:

\begin{lstlisting}[language=bash]
	composer transaction submit -c admin@sardex-open-network -d  '{ "$class": "net.sardex.interlace.DebitTransfer", "amount": 200, "fromAccount": "resource:net.sardex.interlace.CCAccount#a1", "toAccount": "resource:net.sardex.interlace.CCAccount#a2" }'
\end{lstlisting}

A successful debit transfer creates a PendingTransfer entry with status Pending containing an OTP (one-time password). This OTP can be used by the debitor to confirm the transaction. Thus, in the next example "995317396" is used to call a transaction DebitTransferAcknowledge to acknowledge the debit transfer:

\begin{lstlisting}[language=bash]
	composer transaction submit -c admin@sardex-open-network -d  '{ "$class": "net.sardex.interlace.DebitTransferAcknowledge", "transfer": "resource:net.sardex.interlace.PendingTransfer#995317396" }'
\end{lstlisting}

\textbf{The web front-end}

The web front-end currently is a simple website generated by a Yeoman generator provided by the Composer community. The web application can be found in the web app directory.

In order to get the web application to run properly it is necessary to start up the whole network and start the REST server as described in the previous steps.

The web app is based on AngularJS and needs various node.js packages downloaded and installed, which is achieved by calling

\begin{lstlisting}[language=bash]
	cd webapp
	npm install
\end{lstlisting}

After that a development server can be started by calling

\begin{lstlisting}[language=bash]
	cd webapp
	npm start
\end{lstlisting}

npm will start a web server at port 4200. If you work locally it also tries to open a browser which shows the web application. Otherwise one needs to start a browser manually and enter the URL. This is the URL where the server can be reached:

\url{http://interlace.chain:4200}

The webpage is based on AngularJS and communicates over REST with our previously started REST server, enabling asynchronous AJAX-request.

\section{The Chaincode}
\label{sec:chaincode}

This section describes the core business logic, which is found in the \textit{chain} directory. The shell scripts ending with \textit{.sh} were discussed in Section \ref{sec:prototype}, except for \textit{startRestServer.sh} which is handled in the technical details Section \ref{sec:rest-server}. This section focuses on the chaincode implementation which is stored in the directory \textit{lib} illustrated in Figure \ref{fig:chain-structure}.

\begin{figure}[htbp]
\centering
\begin{minipage}{5cm}
\dirtree{%
.1 chain.
	.2 \textbf{lib/}.
		.3 config.js.
		.3 enums.js.
		.3 init.js.
		.3 transactions.js.
	.2 \textbf{models/}.
	.2 \textbf{network/}.
	.2 connection.json.
	.2 data.json.
	.2 \textcolor{green}{initNetwork.sh}.
	.2 package-lock.json.
	.2 package.json.
	.2 permissions.acl.
	.2 queries.qry.
	.2 \textcolor{green}{updateNetwork.sh}.
	.2 \textcolor{green}{startRestServer.sh}.
}
\end{minipage}
\caption{\bf\small Chaincode Directory Structure}
\label{fig:chain-structure}
\end{figure}


In the lib directory, \textit{config.js} contains the main configurations including things like time-outs, quick-transfer amounts, and transfer types and account type mappings, which are done in the form of a JSON object. Unfortunately, Composer doesn't offer static access to enumeration constants. All enumeration values of a type need to be addressed by a string value. This approach is quite dangerous and gives potentially space for a lot of common errors. INTERLACE tries to solve this issue by setting up an object with "frozen"\footnote{\url{https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze}} attributes.

In Listing \ref{lst:enumMap} a JavaScript mapping of the cto model enum type \textit{Unit} in \ref{lst:enumCTO} is illustrated.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=javascript,firstnumber=1,caption={\bf\small JavaScript enumeration mapping}, captionpos=b,label=lst:enumMap]
var Unit = Object.freeze({
  'Euro': 'Euro',
  'SRD': 'SRD'
});
\end{lstlisting}
\end{minipage}
\end{center}

Using this way of enum-mapping, a proper development environment suggests and auto-completes the possible values of an e.g.\ Unit when the user works with it. Instead, there is the possibility, as mentioned, to directly work with string values. But writing \textit{Unit.Euro} instead of \textit{"Euro"} ensures during development when sources are linted\footnote{\url{https://en.wikipedia.org/wiki/Lint_\%28software\%29}} that the correct enumeration names have been applied.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=cto,firstnumber=1,caption={\bf\small enum in CTO-model}, captionpos=b,label=lst:enumCTO]
enum Unit {
  o Euro
  o SRD
}
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Linking Transactions}
\label{sec:link transactions}

There are two JavaScript files which contain the available transactions of the network: \textit{init.js} and \textit{transactions.js}. Before going into the details of what these files contain, we give a simple example of how transactions of the CTO model are mapped to a JavaScript function. Listing \ref{lst:linkTransaction} gives a short example of the syntax through which \textit{CreditTransfer} transactions are linked to a JavaScript function with the same name.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=javascript,firstnumber=1,caption={\bf\small Connection of JavaScript function CreditTransfer to CTO-model transaction type}, captionpos=b,label=lst:linkTransaction]
/**
 * CreditTransfer transaction
 * @param {net.sardex.interlace.CreditTransfer} transfer
 * @transaction
 */
async function CreditTransfer(transfer) { [...] }
\end{lstlisting}
\end{minipage}
\end{center}

In this example the JavaScript name of the function is not important. Rather, what matters is the notation \textit{@transaction}, as well as the definition of the parameter(s) of the function and of their type. More specifically, on line 3 the parameter \textit{transfer} is linked to the CTO model type \textit{net.sardex.interlace.CreditTransfer}. When a CreditTransfer is invoked, usually using a JSON string, this string is converted to a type in JavaScript that has the same properties as \textit{net.sardex.interlace.CreditTransfer} and that is provided as \textit{transfer} input parameter.

Then, during execution the \textit{transfer} input parameter may be used like any JavaScript object and contains all the information necessary to process that transaction request. In JS, it is important that the code be deterministic and that it evaluates to the same result on different peers.

\subsection{Init Blockchain}
\label{subsec:initblockchain}

The only transaction in \textit{init.js} should be executed only once, otherwise it will lead to an inconsistent blockchain if executed twice. The reason is that this initialisation script sets up a couple of participants with an account asset each to immediately test the blockchain. Thus, after the "InitBlockchain" transaction has been executed the chain contains at least two members and two accounts in order to move money around by applying credit and debit operations. Therefore, executing the initialisation multiple times will create a pair of participants each time, leading to a configuration that does not match other parts of the model.

Listing \ref{lst:initBlock} shows parts of the actual creation of an asset as well as of a participant. It uses \textit{getFactory()}, which is part of the Composer API to generate new instances of various types. The factory offers a function \textit{newResource} to actually create first an "Individual" from namespace \textit{net.sardex.interlace} and afterwards a "CCAccount" residing in the same namespace. The namespace is not visible in the script of Listing \ref{lst:initBlock} because it has been configured in the config.js file and applied to the config object.

Function \textit{newResource} uses namespace, type name, and identifier as parameters and, in the case of line 3, for example, gives back a JavaScript representation of "net.sardex.interlace.Individual". The same principle applies to line 8 when a CCAccount is created.

To write a new resource to the ledger a registry of the type super-category has to be acquired.

Given that the Individual is a participant, the \textit{getParticipantRegistry} function needs to be called in order to write it to the chain. For any asset like the CCAccount, it is necessary to call the \textit{getAssetRegistry} function to receive the right registry.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=javascript,firstnumber=1,caption={\bf\small Chaincode adding a new resource in \textit{initBlockchain} function}, captionpos=b,label=lst:initBlock]
let factory = getFactory();

let m1 = factory.newResource(config.NS, 'Individual', 'm1');
m1.firstName='f1';
[...]

let a1 = factory.newResource(config.NS, 'CCAccount', 'a1');
[...]
a1.balance=1000;
a1.member=factory.newRelationship(config.NS, 'Individual', 'm1');
[...]

let partReg = await getParticipantRegistry(config.NS + '.Individual');
await partReg.addAll([m1]);

let accReg = await getAssetRegistry(config.NS + '.CCAccount');
await accReg.addAll([a1]);
\end{lstlisting}
\end{minipage}
\end{center}

Once the registries are available, they can be called as in lines 14 and 17 with the matching type-category, to finally ask to add a new entry to the chain. The Hyperledger Composer API also has  functions for reading, removing or update included. The documentation for the AssetRegistry\footnote{\url{https://hyperledger.github.io/composer/v0.19/api/runtime-assetregistry}} and for the \textit{ParticipantRegistry}\footnote{\url{https://hyperledger.github.io/composer/v0.19/api/runtime-participantregistry}} can be found in the Composer documentation.

\subsection{Main Payment Transactions}
\label{subsec:main-payment-transactions}
The current implementation comes with credit and debit transactions that work according to the specifications made in D2.1 \cite{INTERLACE_D21} and D3.1 \cite{INTERLACE_D31}, except for the requirement concerning the tracking of the debt position over time, \textit{DeltaDebt}, which can be found in D2.3 \cite{INTERLACE_D23}.

\textbf{CreditTransfer chaincode}

Let's now focus on the first of the two payment transactions: the credit transfer. Listing \ref{lst:js-credittransfer} shows the core of the JavaScript function without the additional function wrappers.

The code was written in a way that is supposed to be readable by people who may not be JavaScript experts. Nevertheless, the keyword \textit{await} might  need a brief explanation:\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await}} \textit{await} deals with asynchronous JavaScript function calls and (in simplified terms) just waits until the prefixed function completes its task. If \textit{await} were missing, an asynchronous JavaScript (like previewCheck) would be called and executed in the background and the execution of the current thread would continue immediately.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=javascript,firstnumber=1,caption={\bf\small CreditTransfer JavaScript}, captionpos=b,label=lst:js-credittransfer]
//some basic checks
await checkAmountPlausible(transfer);

// preview check throws error in case of violation
await previewCheck(transfer);

// account limits checks throws error in case of violation
await accountLimitCheck(
  transfer.fromAccount,
  transfer.toAccount,
  transfer.amount);

// check account limits and emits event if violated
await checkAccountLimitsAlerts(transfer.fromAccount);

// perform the transfer
await moveMoney(transfer);
\end{lstlisting}
\end{minipage}
\end{center}

The \textit{transfer} object used in the listing is pre-filled by the chaincode API after a CreditTransfer is invoked. It is created from the parameters and values of the JSON object that is part of the submitted transaction and that follows the structure of the CTO model of type \textit{net.sardex.interlace.CreditTransfer}.

\textbf{DebitTransfer chaincode}

The debit operation, shown in Listing \ref{lst:js-debittransfer}, is a bit more complex compared to a basic credit operation. In that listing only the important part of the function is shown. The leading part calling \textit{checkAmountPlausible}, \textit{previewCheck}, and \textit{accountLimitCheck} is exactly the same as in CreditTransfer and, therefore, it was left out to increase readability.

One note for debit operations resulting from the specifications is that the owner of the fromAccount from the debit transfer is the debitor, who is also the buyer. Whereas the toAccount owner is regarded as the creditor who is selling something. Please see Figure 2.7 in D3.1 \cite{INTERLACE_D31} for the definition of fromAccount, toAccount, and related concepts.

Continuing further with the implementation, the core of the debit operation checks if an immediate transfer is possible (amount smaller than a predefined value) or if a confirmation of the other party is necessary. In case of an immediate transfer the money is moved the same way as in CreditTransfer by calling the \textit{moveMoney} function. If the transfer amount is above a threshold (currently 100 SRD), however, a confirmation needs to be obtained from the debitor who is in our case the owner of the fromAccount of the transfer.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=javascript,firstnumber=1,caption={\bf\small DebitTransfer JavaScript}, captionpos=b,label=lst:js-debittransfer]
// check for immediate transfer possibility
if (transfer.amount <= config.debit.quick_transfer_amount) {
  // perform the transfer
  await moveMoney(transfer);

  // check account limits and emits event if violated
  await checkAccountLimitsAlerts(transfer.fromAccount);
} else { // requires confirmation
  // add the debit transfer to the pending queue
  let otp = await insertPendingTransfer(transfer);

  // create confirmation event RequestDebitAckReqAnswCompletion
  // which is including the OTP and the sender account (of debitor)
  [...]

  // emit the event
  emit(confirmReq);
}
\end{lstlisting}
\end{minipage}
\end{center}

If a confirmation is needed the transaction \textit{DebitTransfer} cannot move the amount from account A to account B instantaneously. To remember all values of that transaction they are stored inside asset \textit{PendingTransfer} which uses an OTP as identifier. The insertion done by Function \textit{insertPendingTransfer} returns a new OTP when successfully, creating a transfer which is awaiting confirmation.

In order to tell a user that there is a pending confirmation waiting \text{DebitTransfer} issues an event called \textit{RequestDebitAcknowledge} of namespace \textit{net.sardex.interlace} defined in the CTO model. When instantiated, the event obtains a reference to the just created \textit{PendingTransfer} which is done by using the \textit{factory} object (received by the composer API) and calling \textit{newRelationship} which utilizes the OTP references.

\textbf{DebitTransferAcknowledge chaincode}

Each entry in PendingTransfer is identified by an OTP in a way that a transfer can be unambiguously selected by providing an OTP. Currently the OTP is generated by hashing the transaction id of the debit transfer. However, if a debitor would like to confirm a transfer of which he was informed by the emitted event, he just needs to pass the OTP as property for the \textit{DebitTransferAcknowledge} transaction.

\textbf{Note:} For production systems this identification might include an additional key since for large numbers of PendingTransfers the OTP generated in this way might not be unique anymore.

Listing \ref{lst:js-ack} shows the main part of \textit{DebitTransferAcknowledge}, which is different from the other transactions. The variable \textit{ack} in the script is a transaction object provided to the function which contains the \textit{PendingTransfer} read into variable \textit{pT}. Then the code tries to verify the \textit{TransactionStatus}. If the transaction is in state \textit{Pending} it may proceed; in any other case an error is thrown and the transaction is discarded (!not! recorded into the ledger).

If the process is continued the timestamp of the transaction is checked against the \textit{expires} date property of the pending transfer. Consequently, if expired, the state is updated to \textit{"Expired"} and function \textit{DebitTransferAcknowledge} returns with the corresponding status \textit{AcknowledgeStatus}.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=javascript,firstnumber=1,caption={\bf\small RequestDebitAcknowledge JavaScript excerpt}, captionpos=b,label=lst:js-ack]
[..]
//get pending transaction
let pT = ack.transfer;

// verify state of pending transfer
if (pT.state !== TransactionStatus.Pending) {
  throw new Error('Transfer is not in state "' +
    TransactionStatus.Pending + '" but in state "' + pT.state + '"');
}

// varify if pending transaction has been expired
if (ack.timestamp >= pT.expires) {
  //update state from Pending to Rejected
  await updatePendingTransaction(pT, TransactionStatus.Expired);

  //prepare return message
  rS.status = TransactionStatus.Expired;
  rS.description = 'OTP ' + pT.otp + ' is expired.';
  return rS; //TODO: raise event
}
[..]
\end{lstlisting}
\end{minipage}
\end{center}

In the later parts of the function, after all of the checks have been passed and the debit transaction can be performed, the execution steps are pretty much the same as in a CreditTransfer. The only difference is that in case of success or error the PendingTransfer asset of the transaction needs to be updated to Performed or Rejected, respectively. A function called \textit{updatePendingTransaction}, also used in line 14 of Listing \ref{lst:js-ack}, takes care of putting the asset PendingTransfer into the right state.

Additionally, in all cases in which \textit{updatePendingTransaction} has been applied, also a status object called \textit{AcknowledgeStatus} is created and returned by the function that contains the resulting status, along with an error message if something went wrong.

\textbf{moveMoney \& DeltaDebt}

Actual movement of an amount from one to an other account is performed by basic addition and subtraction applied to the balances of the respective accounts and, finally, by updating the account assets in the ledger by means of the registry provided by the Hyperledger Composer API.

Another important step, however, which is part of this money transfer and is shown in Listing \ref{lst:js-movemoney}, is an additional functionality which was specified in D2.3 \cite{INTERLACE_D23}. This logic collects all debts, thus, every transactions which are causing the balance to go negative or to increase (in absolute value) an already negative balance. These debts are collected because they are handled similarly to a loan. ALthough they don't incur interest or any additional fees, these debts have a due date of 12 months by when they need to be paid back. See the Appendix of \cite{INTERLACE_D23} for more details.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=javascript,firstnumber=1,caption={\bf\small moveMoney JavaScript excerpt}, captionpos=b,label=lst:js-movemoney]
[..]
// check balance if DeltaDebt entry needs to be added
// !after amount has been substracted!
if (transfer.fromAccount.balance < 0) await createDeltaDebt(transfer);
// check balance if clearing an open DeltaDebt is necessary
// !before amount has been added!
if ((transfer.toAccount.balance - transfer.amount) < 0) {
  await clearDebt(transfer);
}
[..]
\end{lstlisting}
\end{minipage}
\end{center}

The creation of a debt handled by \textit{createDeltaDebt} is straightforward and just adds an entry to asset \textit{DeltaDebt} if a transaction has been detected which causes a negative balance or makes an already negative balance more negative. A new \textit{DeltaDebt} entry receives an original amount, a current amount, an owner id, and of course a due date by when it needs to be paid back.

If however a transaction adds money to the account owner's balance, say with a positive amount "Amount", former \textit{DeltaDebt} entries may be cleared, which is done by querying all debts with a still unpaid amount. This is illustrated in Listing \ref{lst:js-cleardebt}, where a rich query called \textit{selectDeltaDebt} is used to account for all of those unpaid debts. Details of this and other queries are discussed in subsection \ref{subsec:queries}.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=javascript,firstnumber=1,caption={\bf\small clearDebt JavaScript excerpt}, captionpos=b,label=lst:js-cleardebt]
// query result sorted by "oldest" first
let openDelta =
  await query('selectDeltaDebt', {ID: (transfer.toAccount.member.memberID)});
\end{lstlisting}
\end{minipage}
\end{center}

All selected debts are iterated, starting with the oldest first. The available portion of Amount gets subtracted from the current \textit{DeltaDebt} asset. If Amount is bigger than the current debt being examined, the rest of Amount ($amount = amount - deptPos$) is used in the next iteration step towards the clearing of the next-oldest entry of \textit{DeltaDebt}. Thus, this loop continues either until Amount has been all used up or all debts have been paid back, which also means in the latter case that the balance goes back to having a zero or positive value.

\subsection{Additional Transactions}

There is an additional transaction important for maintenance issues. This transaction, called \textit{CleanupPendingTransfer}, is illustrated in Listing \ref{lst:js-cleanupPending} and takes care of handling old entries of asset \textit{PendingTransfer}.

In some cases pending transfers stay unconfirmed for ever because they e.g.\ were issued wrongly by a user, or were duplicates if a connection had been interrupted together with a lost emitted acknowledge-request event. In such cases, for legal and security reasons these transfers have to be set to \textit{Expired}.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=javascript,firstnumber=1,caption={\bf\small clearDebt JavaScript excerpt}, captionpos=b,label=lst:js-cleanupPending]
let expiredPending =
  await query('selectExpiredPendingTransfers', {now: (transfer.timestamp)});
let aR = await getAssetRegistry(config.NS + '.PendingTransfer');

// change all states to expired
expiredPending.forEach(p => p.state = TransactionStatus.Expired);
await aR.updateAll(expiredPending);
\end{lstlisting}
\end{minipage}
\end{center}

First, the chaincode shown selects all expired entries with query \textit{selectExpiredPendingTransfers}. Then it iterates all of them applying the new state. Finally, all entries are updated using the \textit{AssetRegistry}.

As this is a maintenance transaction it should be executed only by an admin or a user with a specific maintenance role.

\subsection{Queries}
\label{subsec:queries}

Using Hyperledger Composer it is easy to read data written into the ledger. This can be done with its bespoke query language by defining a file called \textit{queries.qry}. 

The Hyperledger Composer Query Language\footnote{\url{https://hyperledger.github.io/composer/v0.19/reference/query-language}} is used in INTERLACE to read information about \textit{PendingTransfer} as well as about \textit{DeltaDebt}. Although it looks similar to SQL, it has only a very limited set of operators. Nevertheless, for INTERLACE these limitations are not relevant because simple selection and filtering is sufficient, as can be observed in Listing \ref{lst:queries}.

The first query in the listing \textit{selectExpiredPendingTransfers} is used by transaction \textit{CleanupPendingTransfers} to find all transfers which are outdated and should be marked as \textit{Expired}. More specifically, the \textit{SELECT} keyword expects an asset defined in the CTO model and will return all the entries in the ledger filtered by the \textit{WHERE} condition.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=sql,firstnumber=1,caption={\bf\small INTERLACE business network queries}, captionpos=b,label=lst:queries]
query selectExpiredPendingTransfers {
  description: "select all expired transfer which are still in state pending"
  statement:
      SELECT net.sardex.interlace.PendingTransfer
       WHERE ((expires <= _$now) AND (state == 'Pending'))
}
query selectDeltaDebt {
  description: "select all open debts"
  statement:
      SELECT net.sardex.interlace.DeltaDebt
       WHERE ((deptPos > 0) AND (debitorID == _$ID))
       ORDER BY [created ASC]
}
\end{lstlisting}
\end{minipage}
\end{center}

Here we filter against property \textit{expires} and state equals to 'Pending'. Parameters like \textit{\_\$now} may be supplied using a JSON-like reference from JavaScript.\footnote{\url{https://hyperledger.github.io/composer/v0.19/api/client-businessnetworkconnection\#buildquery}}

In query \textit{selectDeltaDebt}, all the open debts of a particular debitor (member of the circuit) who has id \textit{\_\$ID} are selected. Like parameter \textit{\_\$now}, parameter \textit{\_\$ID} needs to be set by the calling counterparty.

\subsection{Access Control Language File}

The INTERLACE prototype currently only has one user, who is also the admin and user of the whole network -- no certificates have been issued for other users.  This can be easily changed by adopting the .acl file of the implementation and binding certificates to participants.  However, to reduce complexity, especially for people who work first with the demo implementation, the set-up has been kept simple in this regard.

Listing \ref{lst:acl-permissions} shows the INTERLACE Access Control Language file, permissons.acl, which grants access to any user with any operation available.

\begin{center}
\begin{minipage}{0.8\textwidth}
\small
\begin{lstlisting}[language=json,firstnumber=1,caption={\bf\small Access  control configuration for INTERLACE}, captionpos=b,label=lst:acl-permissions]
rule Default {
    description: "Allow all participants access to all resources"
    participant: "ANY"
    operation: ALL
    resource: "net.sardex.interlace.*"
    action: ALLOW
}

rule SystemACL {
  description:  "System ACL to permit all access"
  participant: "ANY"
  operation: ALL
  resource: "org.hyperledger.composer.system.**"
  action: ALLOW
}
\end{lstlisting}
\end{minipage}
\end{center}

Details on how to refine access can be found in the Hyperledger Composer documentation.\footnote{\url{https://hyperledger.github.io/composer/v0.19/tutorials/acl-trading}}

\subsection{Deployment}

As mentioned in Section \ref{subsec:install}, the deployment of the chaincode application has to happen in several steps which are handled by \textit{initNetwork.sh}, or after consecutive changes with \textit{updateNetwork.sh}. Both scripts utilize the hyperledger composer-cli component.

The script \textit{initNetwork.sh} needs to:

\begin{enumerate}
	\item create package.json if it does not exist,
	\item pack all sources into a bna-file,
	\item create a network card for the \textit{ChannelAdmin} as well as the \textit{PeerAdmin} roles,
	\item import that card,
	\item install the new network,
	\item start the new network,
	\item and finally import the network admin card generated by the starting process.
\end{enumerate}

Basically, the script will provide a running business network together with composer cards which are connection profiles used to access the network.

During development the network usually needs to be deployed a couple of times to check and test the implementations. \textit{updateNetwork.sh} was created for this purpose. It reduces these 7 steps necessary for initial install to just 4 that handle an intermediate update. These steps are:

\begin{enumerate}
	\item increase the version of the business network implementation,
	\item re-pack the changed sources into a .bna file with a higher version tag,
	\item install the new .bna file on the network,
	\item and at last upgrade the network to the new version.
\end{enumerate}

\section{REST Server}
\label{sec:rest-server}

A REST server used for connections of client applications can be provided by the Hyperledger Composer REST Server CLI-Tool.\footnote{\url{https://hyperledger.github.io/composer/latest/reference/rest-server}} The REST server is able to connect to the business network and provides access to all assets, transactions, and queries available on the network.

For INTERLACE all the configurations necessary to run this server are gathered inside \textit{startRestServer.sh}. The exposed REST API is shown in Figure \ref{fig:rest-swagger} and is built with Swagger tools.\footnote{\url{https://swagger.io/}}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth]{Figures/rest-swagger}
  \caption{\bf\small REST GUI provided by composer-rest-server using Swagger}
  \label{fig:rest-swagger}
\end{figure}

\section{Web Application}
\label{sec:webapp}

Figure \ref{fig:webapp} shows an illustration of a web page generated for the INTERLACE business network implementation. It was  created using generator-hyperledger-composer,\footnote{\url{https://www.npmjs.com/package/generator-hyperledger-composer}} which is a Yeoman\footnote{\url{http://yeoman.io/}} module.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth]{Figures/webapp}
  \caption{\bf\small An AngularJS-based web application }
  \label{fig:webapp}
\end{figure}

In this web application it is possible to list, add, and edit assets and participants, as well as submit transactions to the network. It is implemented in AngularJS\footnote{\url{https://angular.io/}} and connects to the REST server which is, as mentioned, also provided by the Composer Tools suite. Consequently, it is possible to manage assets like \textit{SysAccount}, \textit{CCAccount}, \textit{PendingTransfer}, and \textit{DeltaDebt}. Participants like \textit{Subscriber} and \textit{Individual} are using these assets, whereas transaction \textit{CreditTransfer}, \textit{DebitTransfer}, \textit{DebitTransferAcknowledge}, and \textit{CleanupPendingTransfer} handle how the assets are processed during application access.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.5\textwidth]{Figures/webapp-transfer}
  \caption{\bf\small Credit/Debit Transfers }
  \label{fig:webapp-transfer}
\end{figure}

With the appropriate permissions, like we have with the admin user, assets may be changed directly, without calling any of the mentioned transactions which normally take care about updating the chain consistently. Further, regardless of how the assets are changed (i.e.\ using custom transactions or just executing changes directly), all manipulations to the chain are recorded to the chain and clearly traceable.

Figure \ref{fig:webapp-transfer} shows the graphical interface for an invocation of a credit/debit transfer. It picks up a \textit{fromAccount}, \textit{toAccount} and the amount that needs to be transferred. As explained in Section \ref{sec:chaincode}, for a \textit{DebitTransfer} to be performed the owner of the \textit{fromAccount} needs to send a \textit{DebitTransferAcknowledge} confirmation.



